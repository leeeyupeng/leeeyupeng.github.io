#include"leetcode.h"

class Solution {
private:
	int n;
	enum STATE {
		STATE_INIT,
		STATE_SYMBOL,
		STATE_INTEGER,
		STATE_POINT_INTEGER,
		STATE_POINT_NOINTEGER,
		STATE_FRACTION,
		STATE_E,
		STATE_E_SYMBOL,
		STATE_E_INTERGER,
		STATE_END,
		STATE_ERROR,
		STATE_COUNT,
	};
	enum CONDITION {
		CONDITION_SPACE,
		CONDITION_SYMBOL,
		CONDITION_DIGIT,
		CONDITION_POINT,
		CONDITION_E,
		CONDITION_ERROR,
		CONDITION_COUNT,
	};

	unordered_map<char, CONDITION> mapchartocondition{
		{' ',CONDITION::CONDITION_SPACE},
		{'+',CONDITION::CONDITION_SYMBOL},
		{'-',CONDITION::CONDITION_SYMBOL},
		{'0',CONDITION::CONDITION_DIGIT},
		{'1',CONDITION::CONDITION_DIGIT},
		{'2',CONDITION::CONDITION_DIGIT},
		{'3',CONDITION::CONDITION_DIGIT},
		{'4',CONDITION::CONDITION_DIGIT},
		{'5',CONDITION::CONDITION_DIGIT},
		{'6',CONDITION::CONDITION_DIGIT},
		{'7',CONDITION::CONDITION_DIGIT},
		{'8',CONDITION::CONDITION_DIGIT},
		{'9',CONDITION::CONDITION_DIGIT},
		{'.',CONDITION::CONDITION_POINT},
		{'e',CONDITION::CONDITION_E},
		{'E',CONDITION::CONDITION_E},
	};
	CONDITION parsecondition(char c) {
		if (mapchartocondition.find(c) != mapchartocondition.end()) {
			return mapchartocondition[c];
		}
		return CONDITION::CONDITION_ERROR;
	}
	STATE transfer[STATE::STATE_COUNT][CONDITION::CONDITION_COUNT] = {
		{STATE::STATE_INIT,STATE::STATE_SYMBOL,STATE::STATE_INTEGER,STATE::STATE_POINT_NOINTEGER,STATE::STATE_ERROR,STATE::STATE_ERROR},
		{STATE::STATE_ERROR,STATE::STATE_ERROR,STATE::STATE_INTEGER,STATE::STATE_POINT_NOINTEGER,STATE::STATE_ERROR,STATE::STATE_ERROR},
		{STATE::STATE_END,STATE::STATE_ERROR,STATE::STATE_INTEGER,STATE::STATE_POINT_INTEGER,STATE::STATE_E,STATE::STATE_ERROR},
		{STATE::STATE_END,STATE::STATE_ERROR,STATE::STATE_FRACTION,STATE::STATE_ERROR,STATE::STATE_E,STATE::STATE_ERROR},
		{STATE::STATE_ERROR,STATE::STATE_ERROR,STATE::STATE_FRACTION,STATE::STATE_ERROR,STATE::STATE_ERROR,STATE::STATE_ERROR},
		{STATE::STATE_END,STATE::STATE_ERROR,STATE::STATE_FRACTION,STATE::STATE_ERROR,STATE::STATE_E,STATE::STATE_ERROR},
		{STATE::STATE_ERROR,STATE::STATE_E_SYMBOL,STATE::STATE_E_INTERGER,STATE::STATE_ERROR,STATE::STATE_ERROR,STATE::STATE_ERROR},
		{STATE::STATE_ERROR,STATE::STATE_ERROR,STATE::STATE_E_INTERGER,STATE::STATE_ERROR,STATE::STATE_ERROR,STATE::STATE_ERROR},
		{STATE::STATE_END,STATE::STATE_ERROR,STATE::STATE_E_INTERGER,STATE::STATE_ERROR,STATE::STATE_ERROR,STATE::STATE_ERROR},
		{STATE::STATE_END,STATE::STATE_ERROR,STATE::STATE_ERROR,STATE::STATE_ERROR,STATE::STATE_ERROR,STATE::STATE_ERROR},
		{STATE::STATE_ERROR,STATE::STATE_ERROR,STATE::STATE_ERROR,STATE::STATE_ERROR,STATE::STATE_ERROR,STATE::STATE_ERROR},
	};
	STATE statetransfer(STATE s, CONDITION c) {
		return transfer[s][c];
	}
public:
	bool isNumber(string s) {
		n = s.length();
		STATE state = STATE::STATE_INIT;
		CONDITION condition;
		for (int i = 0; i < n; i++) {
			condition = parsecondition(s[i]);
			if (condition == CONDITION::CONDITION_ERROR) { return false; }
			state = statetransfer(state,condition);
			if (state == STATE::STATE_ERROR) { return false; }
		}
		state = statetransfer(state, CONDITION::CONDITION_SPACE);
		return  state == STATE::STATE_END;
	}
};

//int main()
//{
//	Solution s;
//	string str = "0";
//	bool ans = s.isNumber(str);
//	cout << ans;
//	system("PAUSE");
//	return 0;
//}